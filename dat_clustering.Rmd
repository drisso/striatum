---
title: "Clustering of DAT cells"
author: "Davide Risso"
date: '`r Sys.Date()`'
output: 
  html_document:
    fig_height: 7
    fig_width: 7
    toc: yes
    code_folding: hide
    toc_float: yes
---

```{r options, include=FALSE}
knitr::opts_chunk$set(cache=TRUE, error=FALSE, message=FALSE,
                      warning=FALSE, resuts = "hide")

library(scone)
library(stringi)
library(RColorBrewer)
library(clusterExperiment)
library(Rtsne)
library(matrixStats)

cols <- c(brewer.pal(9, "Set1"))

options(getClass.msg=FALSE)
NMF::nmf.options(grid.patch=TRUE)
```

```{r datain}
load("data/Oct15/imageAfterFiltering.RData")
dat <- sf.sc.eSet[,sf.sc.eSet$MD_expt_condition == "DAT_EXPT1"]
qc <- protocolData(dat)@data[,-c(6:9, 19)]

batch <- droplevels(dat$MD_c1_run_id)
chip_size <- dat$MD_c1_chip
```

# Filtering low-quality cells

```{r filtering}
counts <- na.omit(assayData(dat)$counts_table)
counts <- counts[rowSums(counts)>0,]

num_reads <- quantile(counts[counts > 0])[4]
num_cells <- 0.25*ncol(counts)
is_common <- rowSums(counts >= num_reads ) >= num_cells
table(is_common)

data(housekeeping)
hk <- intersect(stri_trans_totitle(housekeeping$V1), rownames(counts))

mfilt <- metric_sample_filter(counts,
                             nreads = qc$NREADS,
                             ralign = qc$RALIGN,
                             hard_nreads = 500000,
                             hard_ralign = 85,
                             gene_filter = is_common,
                             pos_controls = rownames(counts) %in% hk,
                             zcut = 3, mixture = FALSE,
                             plot = TRUE)

# Mean log10(x+1) expression
mu_obs <- rowMeans(log10(counts[hk,]+1))

# Assumed False Negatives
drop_outs <- counts[hk,] == 0

# Logistic Regression Model of Failure
ref.glms = list()
for (si in 1:dim(drop_outs)[2]){
  fit = glm(cbind(drop_outs[,si],1 - drop_outs[,si]) ~ mu_obs,
            family=binomial(logit))
  ref.glms[[si]] = fit$coefficients
}

# Plot Failure Curves and Calculate AUC
plot(NULL, main = "False Negative Rate Curves",
     ylim = c(0,1),xlim = c(0,6), 
     ylab = "Failure Probability", xlab = "Mean log10 Expression")
x = (0:60)/10
AUC = NULL
for(si in 1:ncol(counts)){
  y = 1/(exp(-ref.glms[[si]][1] - ref.glms[[si]][2] * x) + 1)
  AUC[si] = sum(y)/10
  lines(x, 1/(exp(-ref.glms[[si]][1] - ref.glms[[si]][2] * x) + 1),
        type = 'l', lwd = 2, col = cols[as.numeric(batch)[si]+1])
}

filtersample = !apply(simplify2array(mfilt[!is.na(mfilt)]), 1, any)

#filtered <- counts[,filtersample]
filtergenes <- rowSums(counts>10)>=10
table(filtergenes)
filtered <- counts[filtergenes,]
qc <- qc[colnames(filtered),]

pca <- prcomp(t(log1p(filtered)), scale. = TRUE)
plot(pca$x[,1:2], pch=19, col=cols[as.numeric(filtersample)+1], main="Raw data")
legend("bottomright", c("low-quality", "high-quality"), fill=cols)

fq <- FQ_FN(filtered)
pca <- prcomp(t(log1p(fq)), scale. = TRUE)
plot(pca$x[,1:2], pch=19, col=cols[as.numeric(filtersample)+1], main="FQ data")
legend("bottomright", c("low-quality", "high-quality"), fill=cols)

qcpca <- prcomp(qc, scale. = TRUE)
plot(qcpca$x[,1:2], pch=19, col=cols[as.numeric(filtersample)+1], main="QC PCA")
legend("bottomright", c("low-quality", "high-quality"), fill=cols)

plot(qc[,c(1, 3)], pch=19, col=cols[as.numeric(filtersample)+1])
legend("bottomright", c("low-quality", "high-quality"), fill=cols)
```

For now, I am removing all the low-quality cells. But I'm wondering if we should
revisit this. Could they be biologically different cell types that express fewer
genes?

```{r filtered}
filtered <- counts[,filtersample]
filtergenes <- rowSums(filtered>10)>=10
filtered <- filtered[filtergenes,]
qc <- qc[colnames(filtered),]
batch <- droplevels(batch[filtersample])
chip_size <- droplevels(chip_size[filtersample])

pca <- prcomp(t(log1p(filtered)), scale. = TRUE)
plot(pca$x[,1:2], pch=19, col=cols[batch], main="Raw data")

fq <- FQ_FN(filtered)
pca <- prcomp(t(log1p(fq)), scale. = TRUE)
plot(pca$x[,1:2], pch=19, col=cols[batch], main="FQ data")

qcpca <- prcomp(qc, scale. = TRUE)
plot(qcpca$x[,1:2], pch=19, col=cols[batch], main="QC PCA")

plot(qc[,c(1, 3)], pch=19, col=cols[batch])
```

# Normalization

Here, we normalize the samples by removing the batch effects and the first two QC PCs,
after FQ normalization.


```{r norm}
Y <- t(log1p(fq))
W <- model.matrix(~batch)
alpha <- solve(t(W) %*% W) %*% t(W) %*% Y
correctedY <- t(Y - W %*% alpha)
#correctedY[correctedY<0] <- 0
pca_dat <- prcomp(t(correctedY), center=TRUE, scale=TRUE)

plot(pca_dat$x, pch=19, col=cols[batch])

## Positive controls: genes found DE between 6 DA neuron subtypes by Poulin et al
poulin <- c("Sox6", "Sncg", "Ndnf", "Igf1", "Foxa2", "Lmx1a", "Aldh1a1", "Slc32a1", "Satb1", "Clstn2", "Adcyap1", "Lpl", "Otx2", "Vip", "Chrna4", "Gsg1l", "Snca", "Ntf3")

linnarson <- c("Epha4", "Chrna5", "Nrip3", "Kcns3", "Cplx1", "Sox6", "Ndnf", "Kifc3", "Calb1", "Chst8", "Aldh1a1", "Igfbp2", "Lama5", "Anxa1", "Rpb4", "Aldh1a7", "Adcyap1", "Lhfpl2", "Cbln4", "Lpl", "Nhlh2", "Otx1", "Syn2", "Cbln1", "Gpx3", "Fjx1", "Foxa2", "En2", "Ntf3", "Gfra2", "Lix1", "Ptpn5", "Fgf1", "Nostrin", "Serpine2", "Kcnip3", "Grik1", "Lypd1", "Pou3f1", "Cd9", "Otx2", "Neurod6", "Grp", "Tcf12", "Calca", "Gpr83", "Vip", "Cck", "Cnr1", "Nphp1", "Chtf8", "Slc32a1", "Ctxn3", "Etv1", "Lmx1a")
poscon <- intersect(c(poulin, linnarson), rownames(fq))

plotHeatmap(log1p(fq[poscon,]))
plotHeatmap(correctedY[poscon,])
```

# Clustering

```{r tightcluster}
seed <- 927501

rsec <- RSEC(fq, isCount = TRUE, minSizes = 5, alphas = 0.3,
             combineProportion = 0.5,
             mergeMethod = "adjP", mergeCutoff = 0.05,
             ncores = 7, random.seed = seed, run = TRUE)

# cl <- clusterMany(fq, isCount = TRUE, dimReduce="PCA", nPCADims = 50, alphas = 0.3,
#                   sequential = TRUE, subsample = TRUE, minSizes = 5,
#                   clusterFun = c("hierarchical01", "tight"),
#                   ks = 4:15, random.seed = seed,
#                   ncores = 7)
# cl <- combineMany(cl, proportion = .5)
# cl <- makeDendrogram(cl, dimReduce = "mad", ndims = 1000)
# plotDendrogram(cl)
# mergeClusters(cl, mergeMethod = "adjP", cutoff = 0.01)
# plotClusters(cl)

plotClusters(rsec)
```

```{r final}
final_tight <- as.factor(clusterMatrixNamed(rsec)[,2])
names(final_tight) <- colnames(fq)

final_merged <- as.factor(primaryClusterNamed(rsec))
names(final_merged) <- colnames(fq)

print(table(final_tight, final_merged))

plotDendrogram(rsec)
plotCoClustering(rsec, whichClusters = 1:2)
```

```{r visualize}
wh_rm <- which(final_tight=="-1")
pca <- prcomp(t(log1p(fq)[,-wh_rm]), scale. = TRUE, center = TRUE)

cols1 <- c(brewer.pal(8, "Set2"), brewer.pal(8, "Set3"))[-10]
cols2 <- brewer.pal(9, "Set1")[-6]
colMerged <- cols2[droplevels(final_merged[-wh_rm])]
colFinal <- cols1[droplevels(final_tight[-wh_rm])]

plot(pca$x, pch=19, col=colFinal, main="PCA")
legend("topright", levels(final_tight)[-1], fill=cols1)
plot(pca$x, pch=19, col=colMerged, main="PCA, merged")
legend("topright", levels(final_merged)[-1], fill=cols2)

vars <- rowVars(log1p(fq))
names(vars) <- rownames(fq)
vars <- sort(vars, decreasing = TRUE)

tsne_data <- Rtsne(t(log1p(fq)[names(vars)[1:500],-wh_rm]),
                   max_iter=2000, perplexity = 20)
plot(tsne_data$Y, pch=19, col=colFinal, main="t-SNE, 500 most variable genes")
plot(tsne_data$Y, pch=19, col=colMerged, main="t-SNE, 500 most variable genes, merged")

plotHeatmap(rsec, whichClusters=1:2, clusterFeaturesData=poscon)
```

```{r heatmap,dependson="genesDE"}
primaryClusterIndex(rsec) <- 2
genes <- getBestFeatures(rsec, contrastType = "Pairs", isCount=TRUE)
head(genes)

plotHeatmap(rsec, clusterSamplesData = "primaryCluster",
            clusterFeaturesData=unique(genes[,"IndexInOriginal"]))

plotHeatmap(rsec, clusterFeaturesData=unique(genes[,"IndexInOriginal"]))
```
